//WORLD GENERATION
Grid::World::World()
{
	//Organizing the array
	{
		int id = 0;
		for (int i = 0; i < Grid::Width; i++)
		{
			for (int j = 0; j < Grid::Height; j++, id++)
			{
				blocksInGrid[id].SetType(World::Block::BlockType::Air);
				blocksInGrid[id].SetLocation(Vec2(float(i), float(j)));
			}
		}
	}

	std::mt19937 rng(std::random_device{}());

	//Surface generation
	{
		std::uniform_real_distribution<float> seeding(0, 100000.0f); //You can change 100000 with any number you want
																	 //But if it's a small number there are big chances that there
																	 //Might be similarities with previous or next maps
																	 //So with a big number, this chance gets smaller

		float seed = seeding(rng); //Taking a random seed/xoffset in time;

		for (int i = 0; i < Grid::Width; i++, seed += 0.0800000f) //If you change 0.2f with bigger numbers, it will get suddenly random
		{
			float j = Noise::PerlinNoise_1D(seed, 2.7182818f, 6.2831853f); //Taking a random noise value based on the seed
															//With a frequency of e, that's what I thought would be the best one
															//And with a amplitude of tau, you can change the freq and the ampl if u want

			j += float(Grid::Height / 2 - 1);				//The perlin values are between 0 and double the amplitude
																//So I just translate it to the middle of the y plane

			blocksInGrid[GetId(i, int(j + 0.5f))].SetType(Block::BlockType::Grass);
		}
	}
	//Surface generation

	////Underground filling
	for (int i = 0; i < Grid::Width; i++)
	{
		int firstDirtBlock = 0;

		//Finding the surfaceBlock's y location
		for (int testForBlock = 0; blocksInGrid[GetId(i, testForBlock - 2)].GetType() != World::Block::BlockType::Grass; testForBlock++)
		{
			firstDirtBlock = testForBlock;
		}

		std::uniform_int_distribution<int> dirtLayer(2, 4);

		const int dLayer = dirtLayer(rng);

		//Adding the stone blocks to fill
		for (int j = firstDirtBlock; j < Grid::Height; j++)
		{
			if (j <= firstDirtBlock + dLayer)
			{
				blocksInGrid[GetId(i, j)].SetType(Grid::World::Block::BlockType::Dirt);
			}
			else
			{
				blocksInGrid[GetId(i, j)].SetType(Grid::World::Block::BlockType::Stone);
			}
		}
	}
	//Underground filling

	//Hole caves generating
	{
		std::uniform_int_distribution<int> Distribuitor(1, 3);
		std::uniform_real_distribution<float> seeding(0, 100000.0f);
		std::vector<Vec2> tunnelEntrances;

		const char nTunnels = Distribuitor(rng);

		//Getting the tunnel's entrances
		for (char i = 0; i < nTunnels; i++)
		{
			//The boundary that the tunnel entrances can be
			tunnelEntrances.push_back(FindTunnelEntranceOnSurface(0, Grid::Width, blocksInGrid, rng)); // + 3, because 3 is the smallest possible radius for the circle
		}

		//Tunnel creation
		for (char TunnelIterator = 0; TunnelIterator < nTunnels; TunnelIterator++)
		{
			const int TunnelLeftExtremity = int(tunnelEntrances.at(TunnelIterator).x) - 5;
			const int TunnelRightExtremity = int(tunnelEntrances.at(TunnelIterator).x) + 5;

			float seed = seeding(rng);

			std::uniform_int_distribution<int> RandRadius(3, 5);

			for (int j = int(tunnelEntrances.at(TunnelIterator).y); j < Grid::Height; j++, seed += 0.0688888f)
			{
				float I = Noise::PerlinNoise_1DWithCubic(seed, 4.1000000f, 5.0000000f);

				I += float(TunnelLeftExtremity);
				int i = int(I);

				//Circle formation to wide the holes
				const int radius = RandRadius(rng);
				const int topLeftX = i - radius;
				const int topLeftY = j - radius;
				const int diameter = (radius * 2) + 1;
				int bottom = topLeftY + diameter;
				int right = topLeftX + diameter;

				//Not to exit the screen
				if (bottom >= Grid::Height)
				{
					bottom = Grid::Height;
				}
				if (right >= Grid::Width)
				{
					right = Grid::Width;
				}

				//Changing every block in the circle's radius to air
				for (int y = topLeftY; y < bottom; ++y)
				{
					for (int x = topLeftX; x < right; ++x)
					{
						const float DistanceSquared = (pow(i - x, 2) + pow(j - y, 2));

						if (DistanceSquared <= float(pow(radius, 2)))
						{
							blocksInGrid[GetId(x, y)].SetType(Block::BlockType::Air);
						}
					}
				}
				//Circle formation to wide the holes
			}
		}
		//Tunnel creation
	}
	//Hole caves generating

	//Ores
	{
		AddOres(Block::BlockType::Coal, blocksInGrid, 0.3333333f, 80.0000000f, 2.0000000f, 1.0800000f, rng);
		AddOres(Block::BlockType::Iron, blocksInGrid, 0.3333333f, 90.0000000f, 1.0000000f, 1.3333333f, rng);
		AddOres(Block::BlockType::Diamond, blocksInGrid, 0.0100000f, rng);
	}
	//Ores
}
//WORLD GENERATION